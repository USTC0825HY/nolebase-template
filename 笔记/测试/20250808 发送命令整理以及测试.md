# DAQ 逻辑的命令下发整理
## 1 整体下发架构
 ```
上位机 → SiTCP → FIFO缓存 → cmd_divide → ELINK → NFEB
 ```
## 2 指令集整理

### 2.1 全局指令
``` verilog
// 系统控制指令实现
assign all_start = sfp_down_cmd_valid && (sfp_down_cmd == 16'hff00);
assign all_stop = sfp_down_cmd_valid && (sfp_down_cmd == 16'hff01);
assign cmd_elink_rst = sfp_down_cmd_valid && (sfp_down_cmd == 16'hff02);
assign nfeb_gclk_sync = sfp_down_cmd_valid && (sfp_down_cmd == 16'hff03);
```

| 指令码      | 指令名称           | 功能描述      | 实现位置      |
| -------- | -------------- | --------- | --------- |
| `0xFF00` | ALL_START      | 开始数据采集    | GBT_TOP.v |
| `0xFF01` | ALL_STOP       | 停止数据采集    | GBT_TOP.v |
| `0xFF02` | CMD_ELINK_RST  | ELINK接口复位 | GBT_TOP.v |
| `0xFF03` | NFEB_GCLK_SYNC | NFEB时钟同步  | GBT_TOP.v |
### 2.2 配置参数指令
#### 2.2.1 cmd_divide. V module 
- 当收到`0xFFF0-0xFFF7`指令时，提取低4位作为目标板卡号
- `cmd_board_num=0`对应NFEB0，`cmd_board_num=7`对应NFEB7
- `cmd_board_num=0xF`为广播模式（未选择特定板卡）
``` verilog
reg [3:0] cmd_board_num = 4'hf;  // 当前选中的板卡号，初始值0xF（广播）

always @ (posedge clk) begin
    if(!resetn) begin
        cmd_board_num <= 4'hf;  // 复位时设为广播模式
    end
    else if (sfp_down_cmd_valid && (sfp_down_cmd[15:4] == 12'hfff)) begin
        cmd_board_num <= sfp_down_cmd[3:0];  // 提取低4位作为板卡号
    end 
    else begin
        cmd_board_num <= cmd_board_num;  // 保持当前选择
    end
end
```


*Tps：代码有一段 gengerate 部分，可以学习一下*
``` verilog
localparam BOARD_ID = 128'hfff7_fff6_fff5_fff4_fff3_fff2_fff1_fff0;
genvar jj;
generate begin
  for(jj = 0; jj < 8; jj = jj+1)
  begin: configuration_back_array
    configuration_back configuration_back_inst(
      .resetn(resetn),
      .clk(clk),
      .board_index(BOARD_ID[jj*16+15 : jj*16]),
      .sfp_down_cmd_valid(sfp_down_cmd_valid),
      .sfp_down_cmd(sfp_down_cmd),
      .threshold_16b(threshold[jj*16+15 : jj*16]),
      .inputdac_16b(input_dac[jj*16+15 : jj*16])
      );
  end
end
endgenerate
```
等价于生成了 8 个 configuration_back module

| jj值 | 位范围      | 提取的16位值        | 十六进制 |
| ---- | ----------- | ------------------- | -------- |
| 0    | `[15:0]`    | `BOARD_ID[15:0]`    | `0xFFF0` |
| 1    | `[31:16]`   | `BOARD_ID[31:16]`   | `0xFFF1` |
| 2    | `[47:32]`   | `BOARD_ID[47:32]`   | `0xFFF2` |
| 3    | `[63:48]`   | `BOARD_ID[63:48]`   | `0xFFF3` |
| 4    | `[79:64]`   | `BOARD_ID[79:64]`   | `0xFFF4` |
| 5    | `[95:80]`   | `BOARD_ID[95:80]`   | `0xFFF5` |
| 6    | `[111:96]`  | `BOARD_ID[111:96]`  | `0xFFF6` |
| 7    | `[127:112]` | `BOARD_ID[127:112]` | `0xFFF7` |

![[Pasted image 20250808202513.png]]

#### 2.2.2 Configuration_back. V
`configuration_back`是**配置参数解析器**，负责：
- 监听特定板卡ID的配置序列
- 解析配置命令并提取参数
- 输出格式化的阈值和DAC参数 threshold_16b  inputdac_16b
``` verilog
assign threshold_16b = {6'b0,threshold_dac2[1],threshold_dac2[2],threshold_dac2[3],threshold_dac2[4],threshold_dac2[5],
threshold_dac2[6],threshold_dac2[7],threshold_dac1[0],threshold_dac1[1],threshold_dac1[2]};
 assign inputdac_16b = {8'b0,input_dac2[5],input_dac2[6],input_dac2[7],input_dac1[0],input_dac1[1],input_dac1[2],
 input_dac1[3],input_dac1[4]};
```
收到特定 board_index 就开始工作了


回到 cmd_divide. V

70-103 是一段关于关于 NFEB_FIFO 输入信息的前处理
也许可以用下面这段 code 代替

**Cmd_board_num 应该会变化？所以说还是得看看多板的命令咋写**
``` verilog
genvar i;  
  generate 
    for (i = 0; i < FE_NUM; i = i + 1) begin : cmd_distribution
      // Command distribution to each board
      assign pc_cmd_to_fifo[i*16+15 : i*16] = (cmd_board_num == i[3:0]) ? sfp_down_cmd : 16'h0000;
      
      // Valid signal generation for each board
      assign pc_cmd_to_fifo_valid_temp[i] = (cmd_board_num == i[3:0]) ? sfp_down_cmd_valid : 1'b0;
      
      // Filter invalid commands (0xFF and 0xFE in high byte)
      assign pc_cmd_to_fifo_valid[i] = (((pc_cmd_to_fifo[i*16+15 : i*16+8] == 8'hff) || 
                                         (pc_cmd_to_fifo[i*16+15 : i*16+8] == 8'hfe)) && 
                                         pc_cmd_to_fifo_valid_temp[i]) ? 1'b0 : pc_cmd_to_fifo_valid_temp[i];
    end
  endgenerate
```

### 2.3 解释下变量 
- 输入信号 `sfp_down_cmd` 是一个 16 位的命令，`sfp_down_cmd_valid` 表示该命令是否有效。
- `cmd_board_num` 是一个 4 位的信号，用于指示当前命令的目标板卡编号。
### 2.4  命令的分发逻辑
1. **目标板卡的判断**:
- 根据 `cmd_board_num`，将 `sfp_down_cmd` 分发到对应的板卡信号 `pc_cmd_to_fifo`。
- 例如，如果 `cmd_board_num == 4'd2`，则 `pc_cmd_to_fifo[47:32]` 会被赋值为 `sfp_down_cmd`，其余部分为 `0`。
2. **有效信号的生成**:
- `pc_cmd_to_fifo_valid_temp` 表示每个板卡的命令是否有效。
- 如果 `cmd_board_num` 对应某个板卡，则该板卡的有效信号为 `sfp_down_cmd_valid`，其余为 `0`。
3. **无效命令的过滤**:
- 如果命令的高 8 位为 `8'hff` 或 `8'hfe`，则认为该命令无效，将有效信号置为 `0`。
- 例如，对于第 2 个板卡：
## 3 **Q 1 -20250808**  
![[Pasted image 20250808210056.png]]

为什么配置一定是位置 77 和 78 对于 threshold_dac 1 threshold_dac 2 的阈值配置？
==解决：都逻辑发现，高 8 位为 `8'hff` 或 `8'hfe` 的命令会被过滤掉不进入 NFEB_FIFO, 但是似乎并不能改变 Configuration_back module 的阈值配置逻辑？==
那咋处理？
``` verilog
always @ (posedge clk) begin
  if(!resetn) begin
    threshold_dac1 <= 0;
    threshold_dac2 <= 0;
  end
  else if((cmd_counter_0==10'd77)&&sfp_down_cmd_valid) begin
    threshold_dac1 <= sfp_down_cmd[7:0];
  end
  else if((cmd_counter_0==10'd78)&&sfp_down_cmd_valid) begin
    threshold_dac2 <= sfp_down_cmd[7:0];
  end
  else begin
    threshold_dac1 <= threshold_dac1;
    threshold_dac2 <= threshold_dac2;
  end
end
```
下面这段也是，为啥一定是位置 160 和 161 对于 input_dac 1 1 input_dac 2 2 的阈值配置？
``` verilog
reg [7:0] input_dac1 = 0;
reg [7:0] input_dac2 = 0; 
always @ (posedge clk) begin
  if(!resetn) begin
    input_dac1 <= 0;
    input_dac2 <= 0;
  end
  else if((cmd_counter_0==10'd160)&&sfp_down_cmd_valid) begin
    input_dac1 <= sfp_down_cmd[7:0];
  end
  else if((cmd_counter_0==10'd161)&&sfp_down_cmd_valid) begin
    input_dac2 <= sfp_down_cmd[7:0];
  end
  else begin
    input_dac1 <= input_dac1;
    input_dac2 <= input_dac2;
  end
end
```



1. 另外需要搞清楚：threshold_dac&input_dac 是干啥用的？==需要查下手册&和师兄讨论==

2. 看起来师兄给的命令（AC01 ==CC00==）和师姐给的命令集（FFE1 FFD0 FE01 ==FFF0== ）都是配置单板的，多板的命令如何写？

# 调试
